<HTML><HEAD>
<TITLE>lsb.queues.5</TITLE>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!-- .ds ]W % -->
<!-- .ds ]L -->
<!-- .nh -->
<!-- ignored unsupported tag .nh -->
<!-- .TH lsb.queues 5 "openlava Version 2.0 - Jan 2012" -->
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>lsb.queues (5)</NOBR><HR></H1>
</CENTER>
<!-- .br -->
<!-- .SH NAME -->
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>lsb.queues</B>
<!-- .SS Overview -->
</BLOCKQUOTE>
<A name=1>

    <H4>&nbsp; &nbsp; Overview</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The lsb.queues file defines the batch queues in an openlava cluster.
<!-- .PP -->
<P>
This file is optional; if no queues are configured, openlava creates a queue
named default, with all parameters set to default values.
<!-- .SS Contents -->
</BLOCKQUOTE>
<A name=2>

    <H4>&nbsp; &nbsp; Contents</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .RS -->
<BLOCKQUOTE>
<!-- .HP 2 -->
<TABLE cellpadding=3>
<TR valign=top><TD colspan=2>
o lsb.queues Structure
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<!-- .SH lsb.queues Structure -->
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
&nbsp; &nbsp; &nbsp;<A HREF=#1>Overview</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#2>Contents</A><BR>
<A HREF=#3>Administrators</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#4>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#5>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#6>Default</A><BR>
<A HREF=#7>Chkpnt</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#8>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#9>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#10>Default</A><BR>
<A HREF=#11>Corelimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#12>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#13>Default</A><BR>
<A HREF=#14>Cpulimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#15>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#16>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#17>Default</A><BR>
<A HREF=#18>Datalimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#19>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#20>Default &nbsp;&nbsp;&nbsp;</A><BR>
<A HREF=#21>Default_host_spec</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#22>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#23>Default</A><BR>
<A HREF=#24>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#25>Syntax</A><BR>
<A HREF=#26>Dispatch_window</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#27>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#28>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#29>Default</A><BR>
<A HREF=#30>Exclusive</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#31>Syntax</A><BR>
<A HREF=#32>Filelimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#33>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#34>Default</A><BR>
<A HREF=#35>Hjob_limit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#36>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#37>Example</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#38>Default</A><BR>
<A HREF=#39>Hosts</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#40>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#41>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#42>Compatibility</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#43>Example 1</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#44>Example 2</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#45>Example 3</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#46>Example 4</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#47>Default</A><BR>
<A HREF=#48>Ignore_deadline</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#49>Syntax</A><BR>
<A HREF=#50>Interactive</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#51>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#52>Default</A><BR>
<A HREF=#53>Job_accept_interval</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#54>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#55>Default</A><BR>
<A HREF=#56>Job_controls</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#57>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#58>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#59>Default</A><BR>
<A HREF=#60>Job_starter</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#61>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#62>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#63>Example</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#64>Default</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#65>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#66>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#67>Example</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#68>Default</A><BR>
<A HREF=#69>Memlimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#70>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#71>OS Memory Limit Enforcement</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#72>Example</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#73>Default</A><BR>
<A HREF=#74>Mig</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#75>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#76>Default</A><BR>
<A HREF=#77>New_job_sched_delay</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#78>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#79>Default</A><BR>
<A HREF=#80>Nice</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#81>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#82>Default</A><BR>
<A HREF=#83>Pjob_limit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#84>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#85>Default</A><BR>
<A HREF=#86>Post_exec</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#87>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#88>Linux</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#89>Default</A><BR>
<A HREF=#90>Pre_exec</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#91>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#92>Default</A><BR>
<A HREF=#93>Processlimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#94>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#95>Default</A><BR>
<A HREF=#96>Proclimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#97>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#98>Default</A><BR>
<A HREF=#99>Qjob_limit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#100>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#101>Default</A><BR>
<A HREF=#102>Queue_name</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#103>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#104>Default</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#105>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#106>Example</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#107>Default</A><BR>
<A HREF=#108>Rerunnable</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#109>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#110>Default</A><BR>
<A HREF=#111>Res_req</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#112>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#113>Default</A><BR>
<A HREF=#114>Resume_cond</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#115>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#116>Description</A><BR>
<A HREF=#117>Run_window</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#118>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#119>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#120>Default</A><BR>
<A HREF=#121>Runlimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#122>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#123>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#124>Default</A><BR>
<A HREF=#125>Slot_reserve</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#126>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#127>Example</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#128>Default</A><BR>
<A HREF=#129>Stacklimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#130>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#131>Default</A><BR>
<A HREF=#132>Stop_cond</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#133>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#134>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#135>Example</A><BR>
<A HREF=#136>Swaplimit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#137>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#138>Default</A><BR>
<A HREF=#139>Terminate_when</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#140>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#141>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#142>Example</A><BR>
<A HREF=#143>Ujob_limit</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#144>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#145>Default</A><BR>
<A HREF=#146>Users</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#147>Syntax</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#148>Description</A><BR>
&nbsp; &nbsp; &nbsp;<A HREF=#149>Default</A><BR>
<A HREF=#150>See Also</A><BR>
</BLOCKQUOTE>
<A name=151>

     <H3>lsb.queues Structure</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Each queue definition begins with the line Begin Queue and ends with
the line End Queue. The queue name must be specified; all other
parameters are optional.
<!-- .SH ADMINISTRATORS -->
</BLOCKQUOTE>
<A name=3>

     <H3>ADMINISTRATORS</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B><A HREF=#3>ADMINISTRATORS</A></B> <B>=</B> <I>user_name</I> | <I>user_group</I> ...
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
List of queue administrators.
<!-- .PP -->
<P>
Queue administrators can perform operations on any user&#146;s job in the
queue, as well as on the queue itself.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (you must be a cluster administrator to operate on this
queue).
<!-- .SH CHKPNT -->
</BLOCKQUOTE>
<A name=7>

     <H3>CHKPNT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax  -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>CHKPNT = </B><I>chkpnt_dir </I>[<I>chkpnt_period</I>]
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Enables automatic checkpointing.
<!-- .PP -->
<P>
The checkpoint directory is the directory where the checkpoint files are
created. Specify an absolute path or a path relative to CWD, do not use
environment variables.
<!-- .PP -->
<P>
Specify the checkpoint period in minutes.
<!-- .PP -->
<P>
Job-level checkpoint parameters override queue-level checkpoint
parameters.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined.
<!-- .SH CORELIMIT -->
</BLOCKQUOTE>
<A name=11>

     <H3>CORELIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>CORELIMIT = </B><I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The per-process (hard) core file size limit (in KB) for all of the
processes belonging to a job from this queue (see <B>getrlimit</B>(<B>2</B>)).
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH CPULIMIT -->
</BLOCKQUOTE>
<A name=14>

     <H3>CPULIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>CPULIMIT = </B>[<I>default_limit</I>] <I>maximum_limit
</I>.PP
where <I>default_limit</I> and <I>maximum_limit</I> are:
<!-- .PP -->
<P>
[<I>hours</I>:]<I>minutes</I>[/<I>host_name</I> | /<I>host_model</I>]
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Maximum normalized CPU time and optionally, the default normalized
CPU time allowed for all processes of a job running in this queue. The
name of a host or host model specifies the CPU time normalization host
to use.
<!-- .PP -->
<P>
If a job dynamically spawns processes, the CPU time used by these
processes is accumulated over the life of the job.
<!-- .PP -->
<P>
Processes that exist for fewer than 30 seconds may be ignored.
<!-- .PP -->
<P>
By default, if a default CPU limit is specified, jobs submitted to the
queue without a job-level CPU limit are killed when the default CPU
limit is reached.
<!-- .PP -->
<P>
If you specify only one limit, it is the maximum, or hard, CPU limit. If
you specify two limits, the first one is the default, or soft, CPU limit,
and the second one is the maximum CPU limit. The number of minutes
may be greater than 59. Therefore, three and a half hours can be
specified either as 3:30 or 210.
<!-- .PP -->
<P>
You can define whether the CPU limit is a per-process limit enforced
by the OS or a per-job limit enforced by openlava with LSB_JOB_CPULIMIT
in lsf.conf.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH DATALIMIT -->
</BLOCKQUOTE>
<A name=18>

     <H3>DATALIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>DATALIMIT =</B> [<I>default_limit</I>] <I>maximum_limit
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The per-process data segment size limit (in KB) for all of the processes
belonging to a job from this queue (see <B>getrlimit</B>(<B>2</B>)).
<!-- .PP -->
<P>
By default, if a default data limit is specified, jobs submitted to the
queue without a job-level data limit are killed when the default data
limit is reached.
<!-- .PP -->
<P>
If you specify only one limit, it is the maximum, or hard, data limit. If
you specify two limits, the first one is the default, or soft, data limit, and
the second one is the maximum data limit
<!-- .SS Default 	  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH DEFAULT_HOST_SPEC -->
</BLOCKQUOTE>
<A name=21>

     <H3>DEFAULT_HOST_SPEC</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>DEFAULT_HOST_SPEC =</B> <I>host_name | host_model
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The default CPU time normalization host for the queue.
<!-- .PP -->
<P>
The CPU factor of the specified host or host model will be used to
normalize the CPU time limit of all jobs in the queue, unless the CPU
time normalization host is specified at the job level.
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined.
<!-- .SH DESCRIPTION  -->
</BLOCKQUOTE>
<A name=148>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>DESCRIPTION =</B> <I>text
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Description of the job queue that will be displayed by <B>bqueues -l.
</B>.PP
This description should clearly describe the service features of this
queue, to help users select the proper queue for each job.
<!-- .PP -->
<P>
The text can include any characters, including white space. The text
can be extended to multiple lines by ending the preceding line with a
backslash (<BLINK>\)</BLINK>. The maximum length for the text is 512 characters.
<!-- .SH DISPATCH_WINDOW -->
</BLOCKQUOTE>
<A name=26>

     <H3>DISPATCH_WINDOW</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax  -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
<B>DISPATCH_WINDOW =</B> <I>time_window </I>...
<P>
<P>
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The time windows in which jobs from this queue are dispatched. Once
dispatched, jobs are no longer affected by the dispatch window.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (always open).
<!-- .SH EXCLUSIVE  -->
</BLOCKQUOTE>
<A name=30>

     <H3>EXCLUSIVE</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax  -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>EXCLUSIVE = Y</B> | <B>N
</B>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
If Y, specifies an exclusive queue.
<!-- .PP -->
<P>
Jobs submitted to an exclusive queue with <B>bsub -x</B> will only be
dispatched to a host that has no other openlava jobs running.
<!-- .SH FILELIMIT -->
</BLOCKQUOTE>
<A name=32>

     <H3>FILELIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>FILELIMIT =</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The per-process (hard) file size limit (in KB) for all of the processes
belonging to a job from this queue (see <B>getrlimit</B>(<B>2</B>)).
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH HJOB_LIMIT -->
</BLOCKQUOTE>
<A name=35>

     <H3>HJOB_LIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B><A HREF=#35>HJOB_LIMIT</A></B> <B>=</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Per-host job slot limit.
<!-- .PP -->
<P>
Maximum number of job slots that this queue can use on any host. This
limit is configured per host, regardless of the number of processors it
may have.
<!-- .PP -->
<P>
This may be useful if the queue dispatches jobs that require a node-
locked license. If there is only one node-locked license per host then
the system should not dispatch more than one job to the host even if
it is a multiprocessor host.
<!-- .SS Example -->
</BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The following will run a maximum of one job on each of hostA, hostB,
and hostC:
<P>
<!-- .PP -->
<P>
Begin Queue
<!-- .br -->
<!-- ... -->
<!-- ignored unsupported tag ... -->
<!-- .br -->
<!-- Need break --><BR>
HJOB_LIMIT = 1
<!-- .br -->
<!-- Need break --><BR>
HOSTS=hostA hostB hostC
<!-- .br -->
<!-- ... -->
<!-- ignored unsupported tag ... -->
<!-- .br -->
<!-- Need break --><BR>
End Queue
<P>
<P>
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH HOSTS -->
</BLOCKQUOTE>
<A name=39>

     <H3>HOSTS</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>HOSTS =</B> [<B>~</B>]<I>host_name</I>[<B>+</B><I>pref_level</I>] |
[<B>~</B>]<I>host_group</I>[<B>+</B><I>pref_level</I>] | <B>others</B>[<B>+</B><I>pref_level</I>] | <B>all</B> | <B>none</B> ...
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
A space-separated list of hosts, host groups, and host partitions on
which jobs from this queue can be run. All the members of the host list
should either belong to a single host partition or not belong to any host
partition. Otherwise, job scheduling may be affected.
<!-- .PP -->
<P>
Any item can be followed by a plus sign (+) and a positive number to
indicate the preference for dispatching a job to that host, host group,
or host partition. A higher number indicates a higher preference. If a
host preference is not given, it is assumed to be 0. Hosts at the same
level of preference are ordered by load.
<!-- .PP -->
<P>
Use the keyword others to indicate all hosts not explicitly listed.
<!-- .PP -->
<P>
Use the not operator (~) to exclude hosts or host groups from the
queue. This is useful if you have a large cluster but only want to
exclude a few hosts from the queue definition.
<!-- .PP -->
<P>
Use the keyword all to indicate all hosts not explicitly excluded.
<!-- .PP -->
<P>
<!-- .SS Compatibility -->
</BLOCKQUOTE>
<A name=42>

    <H4>&nbsp; &nbsp; Compatibility</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Host preferences specified by <B>bsub -m</B> override the queue
specification.
<!-- .SS Example 1  -->
</BLOCKQUOTE>
<A name=43>

    <H4>&nbsp; &nbsp; Example 1</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
HOSTS = hostA+1 hostB hostC+1 GroupX+3
<P>
<P>
<!-- .PP -->
<P>
This example defines three levels of preferences: run jobs on hosts in
GroupX as much as possible, otherwise run on either hostA or hostC
if possible, otherwise run on hostB. Jobs should not run on hostB
unless all other hosts are too busy to accept more jobs.
<!-- .SS Example 2  -->
</BLOCKQUOTE>
<A name=44>

    <H4>&nbsp; &nbsp; Example 2</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
HOSTS = hostD+1 others
<P>
<P>
<!-- .PP -->
<P>
Run jobs on hostD as much as possible, otherwise run jobs on the
least-loaded host available.
<!-- .SS Example 3  -->
</BLOCKQUOTE>
<A name=45>

    <H4>&nbsp; &nbsp; Example 3</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
HOSTS = Group1 ~hostA hostB hostC
<P>
<P>
<!-- .PP -->
<P>
Run jobs on hostB, hostC, and all hosts in Group1 except for hostA.
<!-- .SS Example 4 -->
</BLOCKQUOTE>
<A name=46>

    <H4>&nbsp; &nbsp; Example 4</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
HOSTS = all ~group2 ~hostA
<P>
<P>
<!-- .PP -->
<P>
Run jobs on all hosts in the cluster, except for hostA and the hosts in
group2.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
all (the queue can use all hosts in the cluster, and every host has equal
preference).
<!-- .SH IGNORE_DEADLINE -->
</BLOCKQUOTE>
<A name=48>

     <H3>IGNORE_DEADLINE</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>IGNORE_DEADLINE = Y
</B>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
If Y, disables deadline constraint scheduling (starts all jobs regardless
of deadline contraints).
<!-- .SH INTERACTIVE -->
</BLOCKQUOTE>
<A name=50>

     <H3>INTERACTIVE</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>INTERACTIVE = NO</B> | <B>ONLY
</B>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Causes the queue to reject interactive batch jobs (NO) or accept
nothing but interactive batch jobs (ONLY).
<!-- .PP -->
<P>
Interactive batch jobs are submitted via <B>bsub -I</B>.
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (the queue accepts both interactive and non-interactive
jobs).
<!-- .SH JOB_ACCEPT_INTERVAL -->
</BLOCKQUOTE>
<A name=53>

     <H3>JOB_ACCEPT_INTERVAL</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>JOB_ACCEPT_INTERVAL =</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The number of dispatch turns to wait after dispatching a job to a host,
before dispatching a second job to the same host. By default, a dispatch
turn lasts 60 seconds (MBD_SLEEP_TIME in lsb.params).
<!-- .PP -->
<P>
If 0 (zero), a host may accept more than one job in each dispatch turn.
By default, there is no limit to the total number of jobs that can run on
a host, so if this parameter is set to 0, a very large number of jobs might
be dispatched to a host all at once. You may notice performance
problems if this occurs.
<!-- .PP -->
<P>
JOB_ACCEPT_INTERVAL set at the queue level (lsb.queues)
overrides JOB_ACCEPT_INTERVAL set at the cluster level
(lsb.params).
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (the queue uses JOB_ACCEPT_INTERVAL defined in
lsb.params, which has a default value of 1).
<!-- .SH JOB_CONTROLS -->
</BLOCKQUOTE>
<A name=56>

     <H3>JOB_CONTROLS</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>JOB_CONTROLS = SUSPEND</B>[<I>signal</I> | <I>command</I> | <B><A HREF=#7>CHKPNT</A></B>]
<B>RESUME</B>[<I>signal</I> | <I>command</I>] <B>TERMINATE</B>[<I>signal</I> | <I>command</I> | <B><A HREF=#7>CHKPNT</A></B>]
<!-- .RS -->
<BLOCKQUOTE>
<!-- .HP 2 -->
<TABLE cellpadding=3><!-- tsb: <B>JOB_CONTROLS = SUSPEND</B>[<I>signal</I> | <I>command</I> | <B><A HREF=#7>CHKPNT</A></B>]
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
o CHKPNT is a special action, which causes the system to checkpoint
the job. If the SUSPEND action is CHKPNT, the job is checkpointed
and then stopped by sending the SIGSTOP signal to the job
automatically.
<!-- .HP 2 -->
<BR>
o <I>signal</I> is a UNIX signal name (such as SIGSTOP or SIGTSTP).
<!-- .HP 2 -->
<BR>
o <I>command</I> specifies a /bin/sh command line to be invoked. Do
not specify a signal followed by an action that triggers the same
signal (for example, do not specify
JOB_CONTROLS=TERMINATE[bkill] or
JOB_CONTROLS=TERMINATE[brequeue]). This will cause a
deadlock between the signal and the action.
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Changes the behaviour of the SUSPEND, RESUME, and TERMINATE
actions in openlava.
<!-- .PP -->
<P>
For SUSPEND and RESUME, if the action is a command, the following
points should be considered:
<!-- .RS -->
<BLOCKQUOTE>
<!-- .HP 2 -->
<TABLE cellpadding=3><!-- tsb: For SUSPEND and RESUME, if the action is a command, the following
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
o The contents of the configuration line for the action are run with
/bin/sh -c so you can use shell features in the command.
<!-- .HP 2 -->
<BR>
o The standard input, output, and error of the command are
redirected to the NULL device.
<!-- .HP 2 -->
<BR>
o The command is run as the user of the job.
<!-- .HP 2 -->
<BR>
o All environment variables set for the job are also set for the
command action. The following additional environment variables
are set:
<!-- .RS -->
</TD></TR>
<TR><TD width=2%>&nbsp;</TD><TD>
<!-- .HP 2 -->
<BR>
o LSB_JOBPGIDS -- a list of current process group IDs of the job
<!-- .HP 2 -->
<BR>
o LSB_JOBPIDS --a list of current process IDs of the job
<!-- .RE -->
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<!-- .IP -->
<TABLE cellpadding=3>
<TR valign=top><TD width=6%>

</TD><TD>
For the SUSPEND action command, the following environment
variable is also set:
<P>
<!-- .RS -->
<!-- .HP 2 -->
<TABLE width=100% cellpadding=3>
<TR valign=top><TD colspan=2>
o LSB_SUSP_REASONS -- an integer representing a bitmap of
suspending reasons as defined in lsbatch.h
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=2%>

</TD><TD>
The suspending reason can allow the command to take
different actions based on the reason for suspending the job.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<!-- .SS Default -->
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
On LINUX, by default, SUSPEND sends SIGTSTP for parallel or
interactive jobs and SIGSTOP for other jobs. RESUME sends SIGCONT.
TERMINATE sends SIGINT, SIGTERM and SIGKILL in that order.
<!-- .SH JOB_STARTER -->
</BLOCKQUOTE>
<A name=60>

     <H3>JOB_STARTER</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>JOB_STARTER =</B> <I>starter</I> [<I>starter</I>] [<B>"%USRCMD"</B>] [<I>starter</I>]
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Creates a specific environment for submitted jobs prior to execution.
<!-- .PP -->
<P>
<I>starter</I> is any executable that can be used to start the job (i.e., can
accept the job as an input argument). Optionally, additional strings can
be specified.
<!-- .PP -->
<P>
By default, the user commands run after the job starter. A special string,
%USRCMD, can be used to represent the position of the user&#146;s job in
the job starter command line. The %USRCMD string may be enclosed
with quotes or followed by additional commands.
<!-- .SS Example -->
</BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
JOB_STARTER = csh -c "%USRCMD;sleep 10"
<P>
<P>
<!-- .PP -->
<P>
In this case, if a user submits a job
<P>
<!-- .PP -->
<P>
% bsub myjob arguments
<P>
<P>
<!-- .PP -->
<P>
the command that actually runs is:
<P>
<!-- .PP -->
<P>
% csh -c "myjob arguments;sleep 10"
<P>
<P>
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (no job starter).
<!-- .SH load_index -->
</BLOCKQUOTE>
<A name=>

     <H3>load_index</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<I>load_index</I> <B>=</B> <I>loadSched</I>[<B>/</B><I>loadStop</I>]
<!-- .PP -->
<P>
Specify io, it, ls, mem, pg, r15s, r1m, r15m, swp, tmp, ut, or a non-
shared custom external load index. Specify multiple lines to configure
thresholds for multiple load indices.
<!-- .PP -->
<P>
Specify io, it, ls, mem, pg, r15s, r1m, r15m, swp, tmp, ut, or a non-
shared custom external load index as a column. Specify multiple
columns to configure thresholds for multiple load indices.
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Scheduling and suspending thresholds for the specified dynamic load
index.
<!-- .PP -->
<P>
The loadSched condition must be satisfied before a job is dispatched
to the host. If a RESUME_COND is not specified, the loadSched
condition must also be satisfied before a suspended job can be
resumed.
<!-- .PP -->
<P>
If the loadStop condition is satisfied, a job on the host will be
suspended.
<!-- .PP -->
<P>
The loadSched and loadStop thresholds permit the specification of
conditions using simple AND/OR logic. Any load index that does not
have a configured threshold has no effect on job scheduling.
<!-- .PP -->
<P>
openlava will not suspend a job if the job is the only batch job running on
the host and the machine is interactively idle (it&gt;0).
<!-- .PP -->
<P>
The r15s, r1m, and r15m CPU run queue length conditions are
compared to the effective queue length as reported by <B>lsload -E</B>,
which is normalized for multiprocessor hosts. Thresholds for these
parameters should be set at appropriate levels for single processor
hosts.
<!-- .SS Example  -->
</BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
MEM=2.0/10
<!-- .br -->
<!-- Need break --><BR>
SWAP=200/30
<P>
<P>
<!-- .PP -->
<P>
These two lines translate into a loadSched condition of
<P>
<!-- .PP -->
<P>
mem&gt;=2.0 && swap&gt;=200
<P>
<P>
<!-- .PP -->
<P>
and a loadStop condition of
<P>
<!-- .PP -->
<P>
mem &lt; 10 || swap &lt; 30
<P>
<P>
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined.
<!-- .SH MEMLIMIT -->
</BLOCKQUOTE>
<A name=69>

     <H3>MEMLIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>MEMLIMIT =</B> [<I>default_limit</I>] <I>maximum_limit
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The per-process (hard) process resident set size limit (in KB) for all of
the processes belonging to a job from this queue (see <B>getrlimit</B>(<B>2</B>)).
<!-- .PP -->
<P>
Sets the maximum amount of physical memory (resident set size, RSS)
that may be allocated to a process.
<!-- .PP -->
<P>
By default, if a default memory limit is specified, jobs submitted to the
queue without a job-level memory limit are killed when the default
memory limit is reached.
<!-- .PP -->
<P>
If you specify only one limit, it is the maximum, or hard, memory limit.
If you specify two limits, the first one is the default, or soft, memory
limit, and the second one is the maximum memory limit.
<!-- .PP -->
<P>
openlava has two methods of enforcing memory usage:
<!-- .RS -->
<BLOCKQUOTE>
<!-- .HP 2 -->
<TABLE cellpadding=3><!-- tsb: openlava has two methods of enforcing memory usage:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
o OS Memory Limit Enforcement
<!-- .HP 2 -->
<BR>
o openlava Memory Limit Enforcement
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<!-- .SS OS Memory Limit Enforcement -->
</BLOCKQUOTE>
<A name=71>

    <H4>&nbsp; &nbsp; OS Memory Limit Enforcement</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
OS memory limit enforcement is the default MEMLIMIT behavior and
does not require further configuration. OS enforcement usually allows
the process to eventually run to completion. openlava passes MEMLIMIT to
the OS which uses it as a guide for the system scheduler and memory
allocator. The system may allocate more memory to a process if there
is a surplus. When memory is low, the system takes memory from and
lowers the scheduling priority (re-nice) of a process that has exceeded
its declared MEMLIMIT. Only available on systems that support
<B>RUSAGE_RSS</B> for <B>setrlimit()</B>.
<!-- .RE -->
</BLOCKQUOTE>
<!-- .SS openlava Memory Limit Enforcement -->
<A name=>

    <H4>&nbsp; &nbsp; openlava Memory Limit Enforcement</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
To enable openlava memory limit enforcement, set
LSB_MEMLIMIT_ENFORCE in lsf.conf to y. openlava memory limit
enforcement explicitly sends a signal to kill a running process once it
has allocated memory past MEMLIMIT.
<!-- .PP -->
<P>
You can also enable openlava memory limit enforcement by setting
LSB_JOB_MEMLIMIT in lsf.conf to y. The difference between
LSB_JOB_MEMLIMIT set to y and LSB_MEMLIMIT_ENFORCE set to y is
that with LSB_JOB_MEMLIMIT, only the per-job memory limit enforced
by openlava is enabled. The per-process memory limit enforced by the OS
is disabled. With LSB_MEMLIMIT_ENFORCE set to y, both the per-job
memory limit enforced by openlava and the per-process memory limit
enforced by the OS are enabled.
<!-- .PP -->
<P>
Available for all systems on which openlava collects total memory usage.
<!-- .SS Example -->
</BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The following configuration defines a queue with a memory limit of
5000 KB:
<P>
<!-- .PP -->
<P>
Begin Queue
<!-- .br -->
<!-- Need break --><BR>
QUEUE_NAME  = default
<!-- .br -->
<!-- Need break --><BR>
DESCRIPTION = Queue with memory limit of 5000 kbytes
<!-- .br -->
<!-- Need break --><BR>
MEMLIMIT    = 5000
<!-- .br -->
<!-- Need break --><BR>
End Queue
<P>
<P>
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH MIG -->
</BLOCKQUOTE>
<A name=74>

     <H3>MIG</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>MIG =</B> <I>minutes
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Enables automatic job migration and specifies the migration threshold,
in minutes.
<!-- .PP -->
<P>
If a checkpointable or rerunnable job dispatched to the host is
suspended (SSUSP state) for longer than the specified number of
minutes, the job is migrated (unless another job on the same host is
being migrated). A value of 0 (zero) specifies that a suspended job
should be migrated immediately.
<!-- .PP -->
<P>
If a migration threshold is defined at both host and queue levels, the
lower threshold is used.
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (no automatic job migration).
<!-- .SH NEW_JOB_SCHED_DELAY -->
</BLOCKQUOTE>
<A name=77>

     <H3>NEW_JOB_SCHED_DELAY</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>NEW_JOB_SCHED_DELAY =</B> <I>seconds
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The maximum or minimum length of time that a new job waits before
being dispatched; the behavior depends on whether the delay period
specified is longer or shorter than a regular dispatch interval
(MBD_SLEEP_TIME in lsb.params, 60 seconds by default).
<!-- .RS -->
<BLOCKQUOTE>
<!-- .HP 2 -->
<TABLE cellpadding=3><!-- tsb: The maximum or minimum length of time that a new job waits before
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
o If less than the dispatch interval, specifies the maximum number of
seconds to wait, after a new job is submitted, before starting a new
dispatch turn and scheduling the job. Usually, this causes openlava to
schedule dispatch turns more frequently. You might notice
performance problems (affecting the entire cluster) if this value is
set too low in a busy queue.
<!-- .HP 2 -->
<BR>
o If 0 (zero), starts a new dispatch turn as soon as a job is submitted
to this queue (affecting the entire cluster).
<!-- .HP 2 -->
<BR>
o If greater than the dispatch interval, specifies the minimum number
of seconds to wait, after a new job is submitted, before scheduling
the job. Has no effect of the timing of the dispatch turns, but new
jobs in this queue are always delayed by one or more dispatch
turns.
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
10 seconds.
<!-- .SH NICE -->
</BLOCKQUOTE>
<A name=80>

     <H3>NICE</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>NICE =</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Adjusts the LINUX scheduling priority at which jobs from this queue
execute.
<!-- .PP -->
<P>
The default value of 0 (zero) maintains the default scheduling priority
for UNIX interactive jobs. This value adjusts the run-time priorities for
batch jobs on a queue-by-queue basis, to control their effect on other
batch or interactive jobs. See the <B>nice</B>(<B>1</B>) manual page for more details.
<!-- .PP -->
<P>
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
0 (zero)
<!-- .SH PJOB_LIMIT -->
</BLOCKQUOTE>
<A name=83>

     <H3>PJOB_LIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>PJOB_LIMIT =</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Per-processor job slot limit for the queue.
<!-- .PP -->
<P>
Maximum number of job slots that this queue can use on any
processor. This limit is configured per processor, so that multiprocessor
hosts automatically run more jobs.
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH POST_EXEC -->
</BLOCKQUOTE>
<A name=86>

     <H3>POST_EXEC</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>POST_EXEC = </B><I>command
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
A command run on the execution host after the job.
<!-- .SS LINUX  -->
</BLOCKQUOTE>
<A name=88>

    <H4>&nbsp; &nbsp; LINUX</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The entire contents of the configuration line of the pre- and post-
execution commands are run under /bin/sh -c, so shell features can
be used in the command.
<!-- .PP -->
<P>
The pre- and post-execution commands are run in /tmp.
<!-- .PP -->
<P>
Standard input and standard output and error are set to:
<!-- .PP -->
<P>
/dev/null
<!-- .PP -->
<P>
The output from the pre- and post-execution commands can be
explicitly redirected to a file for debugging purposes.
<!-- .PP -->
<P>
The PATH environment variable is set to:
<P>
<!-- .PP -->
<P>
"/bin /usr/bin /sbin/usr/sbin"
<!-- .RE -->
</BLOCKQUOTE>
<!-- .SS Default  -->
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
No post-execution commands
<!-- .SH PRE_EXEC -->
</BLOCKQUOTE>
<A name=90>

     <H3>PRE_EXEC</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>PRE_EXEC = </B><I>command
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
A command run on the execution host before the job.
<!-- .PP -->
<P>
To specify a pre-execution command at the job level, use <B>bsub -E</B>. If
both queue and job level pre-execution commands are specified, the
job level pre-execution is run after the queue level pre-execution
command.
<!-- .PP -->
<P>
For LINUX:
<!-- .RS -->
<BLOCKQUOTE>
<!-- .HP 2 -->
<TABLE cellpadding=3><!-- tsb: For LINUX:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
o The entire contents of the configuration line of the pre- and post-
execution commands are run under /bin/sh -c, so shell features
can be used in the command.
<!-- .HP 2 -->
<BR>
o The pre- and post-execution commands are run in /tmp.
<!-- .HP 2 -->
<BR>
o Standard input and standard output and error are set to: /dev/null
<!-- .HP 2 -->
<BR>
o The output from the pre- and post-execution commands can be
explicitly redirected to a file for debugging purposes.
<!-- .HP 2 -->
<BR>
o The PATH environment variable is set to:
/bin /usr/bin /sbin/usr/sbin
<!-- .HP 2 -->
<BR>
o If the pre-execution command exits with a non-zero exit code, it is
considered to have failed, and the job is requeued to the head of
the queue. This feature can be used to implement customized
scheduling by having the pre-execution command fail if conditions
for dispatching the job are not met.
<!-- .HP 2 -->
<BR>
o Other environment variables set for the job are also set for the pre-
and post-execution commands.
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
No pre-execution commands
<!-- .SH PROCESSLIMIT -->
</BLOCKQUOTE>
<A name=93>

     <H3>PROCESSLIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>PROCESSLIMIT =</B> [<I>default_limit</I>] <I>maximum_limit
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Limits the number of concurrent processes that can be part of a job.
<!-- .PP -->
<P>
By default, if a default process limit is specified, jobs submitted to the
queue without a job-level process limit are killed when the default
process limit is reached.
<!-- .PP -->
<P>
If you specify only one limit, it is the maximum, or hard, process limit.
If you specify two limits, the first one is the default, or soft, process
limit, and the second one is the maximum process limit.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH PROCLIMIT -->
</BLOCKQUOTE>
<A name=96>

     <H3>PROCLIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>PROCLIMIT =</B> [<I>minimum_limit</I> [<I>default_limit</I>]] <I>maximum_limit
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Maximum number of slots that can be allocated to a job. For parallel
jobs, the maximum number of processors that can be allocated to t he
job.
<!-- .PP -->
<P>
Optionally specifies the minimum and default number of job slots.
<!-- .PP -->
<P>
Jobs that specify fewer slots than the minimum PROCLIMIT or more
slots than the maximum PROCLIMIT cannot use this queue and are
rejected.
<!-- .PP -->
<P>
All limits must be positive numbers greater than or equal to 1 that
satisfy the following relationship:
<!-- .PP -->
<P>
1 &lt;= <I>minimum</I> &lt;= <I>default</I> &lt;= <I>maximum
</I>.PP
You can specify up to three limits in the PROCLIMIT parameter:
<!-- .PP -->
<P>
If you specify one limit, it is the maximum processor limit. The
minimum and default limits are set to 1.
<!-- .PP -->
<P>
If you specify two limits, the first is the minimum processor limit, and
the second one is the maximum. The default is set equal to the
minimum. The minimum must be less than or equal to the maximum.
<!-- .PP -->
<P>
If you specify three limits, the first is the minimum processor limit, the
second is the default processor limit, and the third is the maximum.The
minimum must be less than the default and the maximum.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited, the default number of slots is 1.
<!-- .SH QJOB_LIMIT -->
</BLOCKQUOTE>
<A name=99>

     <H3>QJOB_LIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B><A HREF=#99>QJOB_LIMIT</A></B> <B>=</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Job slot limit for the queue. Total number of job slots that this queue
can use.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH QUEUE_NAME -->
</BLOCKQUOTE>
<A name=102>

     <H3>QUEUE_NAME</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>QUEUE_NAME =</B> <I>string
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Required. Name of the queue.
<!-- .PP -->
<P>
Specify any ASCII string up to 40 characters long. You can use letters,
digits, underscores (_) or dashes (-). You cannot use blank spaces. You
cannot specify the reserved name default.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
You must specify this parameter to define a queue. The default queue
automatically created by openlava is named default.
<!-- .PP -->
<P>
<B>REQUEUE_EXIT_VALUES</B> <B>=</B> [<I>exit_code </I>...] [<B>EXCLUDE(</B><I>exit_code ...</I><B>)</B>]
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Enables automatic job requeue and sets the LSB_EXIT_REQUEUE
environment variable.
<!-- .PP -->
<P>
Separate multiple exit codes with spaces. Define an exit code as
EXCLUDE(<I>exit_code</I>) to enable exclusive job requeue. Exclusive job
requeue does not work for parallel jobs.
<!-- .PP -->
<P>
Jobs are requeued to the head of the queue from which they were
dispatched. The output from the failed run is not saved, and the user
is not notified by openlava.
<!-- .PP -->
<P>
A job terminated by a signal is not requeued.
<!-- .PP -->
<P>
If MBD is restarted, it will not remember the previous hosts from which
the job exited with an exclusive requeue exit code. In this situation, it
is possible for a job to be dispatched to hosts on which the job has
previously exited with an exclusive exit code.
<!-- .PP -->
<P>
Automatic job requeue and exclusive job requeue are described in the
<I>openlava Administrator&#146;s Guide</I>.
<!-- .SS Example  -->
</BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
REQUEUE_EXIT_VALUES=30 EXCLUDE(20)
<P>
<P>
<!-- .PP -->
<P>
means that jobs with exit code 30 are requeued, jobs with exit code 20
are requeued exclusively, and jobs with any other exit code are not
requeued.
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (jobs in this queue are not requeued)
<!-- .SH RERUNNABLE -->
</BLOCKQUOTE>
<A name=108>

     <H3>RERUNNABLE</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>RERUNNABLE = yes</B> | <B>no
</B>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
If yes, enables automatic job rerun (restart).
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
no
<!-- .SH RES_REQ -->
</BLOCKQUOTE>
<A name=111>

     <H3>RES_REQ</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>RES_REQ =</B> <I>res_req
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Resource requirements used to determine eligible hosts. Specify a
resource requirement string as usual. The resource requirement string
lets you specify conditions in a more flexible manner than using the
load thresholds.
<!-- .PP -->
<P>
The select section defined at the queue level must be satisfied at in
addition to any job-level requirements or load thresholds.
<!-- .PP -->
<P>
The rusage section defined at the queue level overrides the rusage
section defined at the job level, and jobs are rejected if they specify
resource reservation requirements that exceed the requirements
specified at the queue level.
<!-- .PP -->
<P>
The order section defined at the queue level is ignored if any resource
requirements are specified at the job level (if the job-level resource
requirements do not include the order section, the default order,
r15s:pg, is used instead of the queue-level resource requirement).
<!-- .PP -->
<P>
The span section defined at the queue level is ignored if the span
section is also defined at the job level.
<!-- .PP -->
<P>
If RES_REQ is defined at the queue level and there are no load
thresholds defined, the pending reasons for each individual load index
will not be displayed by <B>bjobs</B>.
<!-- .SS Default  -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
select[type==local] order[r15s:pg]. If this parameter is defined and
a host model or Boolean resource is specified, the default type will be
any.
<!-- .SH RESUME_COND -->
</BLOCKQUOTE>
<A name=114>

     <H3>RESUME_COND</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>RESUME_COND = </B><I>res_req
</I>.PP
Use the select section of the resource requirement string to specify
load thresholds. All other sections are ignored.
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
openlava automatically resumes a suspended (SSUSP) job in this queue if the
load on the host satisfies the specified conditions.
<!-- .PP -->
<P>
If RESUME_COND is not defined, then the loadSched thresholds are
used to control resuming of jobs. The loadSched thresholds are
ignored, when resuming jobs, if RESUME_COND is defined.
<!-- .SH RUN_WINDOW -->
</BLOCKQUOTE>
<A name=117>

     <H3>RUN_WINDOW</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax  -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>RUN_WINDOW =</B> <I>time_window </I>...
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Time periods during which jobs in the queue are allowed to run.
<!-- .PP -->
<P>
When the window closes, openlava suspends jobs running in the queue and
stops dispatching jobs from the queue. When the window reopens, openlava
resumes the suspended jobs and begins dispatching additional jobs.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (queue is always active)
<!-- .SH RUNLIMIT -->
</BLOCKQUOTE>
<A name=121>

     <H3>RUNLIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>RUNLIMIT = </B>[<I>default_limit</I>] <I>maximum_limit
</I>.PP
where <I>default_limit</I> and <I>maximum_limit</I> are:
<!-- .PP -->
<P>
[<I>hours</I>:]<I>minutes</I>[/<I>host_name</I> | /<I>host_model</I>]
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The maximum run limit and optionally the default run limit. The name
of a host or host model specifies the run time normalization host to use.
<!-- .PP -->
<P>
By default, jobs that are in the RUN state for longer than the specified
maximum run limit are killed by openlava. You can optionally provide your
own termination job action to override this default.
<!-- .PP -->
<P>
Jobs submitted with a job-level run limit (<B>bsub -W</B>) that is less than the
maximum run limit are killed when their job-level run limit is reached.
Jobs submitted with a run limit greater than the maximum run limit are
rejected by the queue.
<!-- .PP -->
<P>
If a default run limit is specified, jobs submitted to the queue without
a job-level run limit are killed when the default run limit is reached.
<!-- .PP -->
<P>
If you specify only one limit, it is the maximum, or hard, run limit. If
you specify two limits, the first one is the default, or soft, run limit, and
the second one is the maximum run limit. The number of minutes may
be greater than 59. Therefore, three and a half hours can be specified
either as 3:30, or 210.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH SLOT_RESERVE -->
</BLOCKQUOTE>
<A name=125>

     <H3>SLOT_RESERVE</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>SLOT_RESERVE = MAX_RESERVE_TIME[</B><I>integer</I><B>]
</B>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Enables processor reservation and specifies the number of dispatch
turns over which a parallel job can reserve job slots.
<!-- .PP -->
<P>
After this time, if a job has not accumulated enough job slots to start, it
releases all its reserved job slots. This means a job cannot reserve job
slots for more than (<I>integer </I>* MBD_SLEEP_TIME) seconds.
<!-- .PP -->
<P>
MBD_SLEEP_TIME is defined in lsb.params; the default value is 60
seconds.
<!-- .SS Example -->
</BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
SLOT_RESERVE = MAX_RESERVE_TIME[5]
<P>
<P>
<!-- .PP -->
<P>
This example specifies that parallel jobs have up to 5 dispatch turns to
reserve sufficient job slots (equal to 5 minutes, by default).
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Undefined (no processor reservation)
<!-- .SH STACKLIMIT -->
</BLOCKQUOTE>
<A name=129>

     <H3>STACKLIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>STACKLIMIT =</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The per-process (hard) stack segment size limit (in KB) for all of the
processes belonging to a job from this queue (see <B>getrlimit</B>(<B>2</B>)).
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH STOP_COND -->
</BLOCKQUOTE>
<A name=132>

     <H3>STOP_COND</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>STOP_COND =</B> <I>res_req
</I>.PP
Use the select section of the resource requirement string to specify
load thresholds. All other sections are ignored.
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
openlava automatically suspends a running job in this queue if the load on
the host satisfies the specified conditions.
<!-- .RS -->
<BLOCKQUOTE>
<!-- .HP 2 -->
<TABLE cellpadding=3><!-- tsb: openlava automatically suspends a running job in this queue if the load on
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
o openlava will not suspend the only job running on the host if the
machine is interactively idle (it &gt; 0).
<!-- .HP 2 -->
<BR>
o openlava will not suspend a forced job (<B>brun -f</B>).
<!-- .HP 2 -->
<BR>
o openlava will not suspend a job because of paging rate if the machine is
interactively idle.
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<!-- .PP -->
<P>
If STOP_COND is specified in the queue and there are no load
thresholds, the suspending reasons for each individual load index will
not be displayed by <B>bjobs</B>.
<!-- .SS Example -->
</BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<P>
<!-- .PP -->
<P>
STOP_COND= select[((!cs && it &lt; 5) || (cs && mem &lt; 15 && swap &lt;
50))]
<P>
<P>
<!-- .PP -->
<P>
In this example, assume "cs" is a Boolean resource indicating that the
host is a computer server. The stop condition for jobs running on
computer servers is based on the availability of swap memory. The stop
condition for jobs running on other kinds of hosts is based on the idle
time.
<!-- .SH SWAPLIMIT -->
</BLOCKQUOTE>
<A name=136>

     <H3>SWAPLIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>SWAPLIMIT =</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
The amount of total virtual memory limit (in KB) for a job from this
queue.
<!-- .PP -->
<P>
This limit applies to the whole job, no matter how many processes the
job may contain.
<!-- .PP -->
<P>
The action taken when a job exceeds its SWAPLIMIT or PROCESSLIMIT
is to send SIGQUIT, SIGINT, SIGTERM, and SIGKILL in sequence. For
CPULIMIT, SIGXCPU is sent before SIGINT, SIGTERM, and SIGKILL.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH TERMINATE_WHEN -->
</BLOCKQUOTE>
<A name=139>

     <H3>TERMINATE_WHEN</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Configures the queue to invoke the TERMINATE action instead of the
SUSPEND action in the specified circumstance.
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>TERMINATE_WHEN = WINDOW</B> | <B>LOAD</B>
.RS
<!-- .HP 2 -->
<TABLE cellpadding=3><!-- tsb: <B>TERMINATE_WHEN = WINDOW</B> | <B>LOAD</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
o WINDOW -- kills jobs if the run window closes.
<!-- .HP 2 -->
<BR>
o LOAD -- kills jobs when the load exceeds the suspending
thresholds.
<!-- .SS Example -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=142>

    <H4>&nbsp; &nbsp; Example</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Set TERMINATE_WHEN to WINDOW to define a night queue that will
kill jobs if the run window closes:
<P>
<!-- .PP -->
<P>
Begin Queue
<!-- .br -->
<!-- Need break --><BR>
NAME           = night
<!-- .br -->
<!-- Need break --><BR>
RUN_WINDOW     = 20:00-08:00
<!-- .br -->
<!-- Need break --><BR>
TERMINATE_WHEN = WINDOW
<!-- .br -->
<!-- Need break --><BR>
JOB_CONTROLS   = TERMINATE[kill -KILL $LS_JOBPGIDS; mail - s
"job $LSB_JOBID killed by queue run window" $USER &lt; /dev/null]
<!-- .br -->
<!-- Need break --><BR>
End Queue
<P>
<P>
<!-- .SH UJOB_LIMIT -->
</BLOCKQUOTE>
<A name=143>

     <H3>UJOB_LIMIT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B><A HREF=#143>UJOB_LIMIT</A></B> <B>=</B> <I>integer
</I>.SS Description
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Per-user job slot limit for the queue. Maximum number of job slots that
each user can use in this queue.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
Unlimited
<!-- .SH USERS -->
</BLOCKQUOTE>
<A name=146>

     <H3>USERS</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .SS Syntax -->
</BLOCKQUOTE>
<A name=147>

    <H4>&nbsp; &nbsp; Syntax</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
<B>USERS =</B> <B>all</B> | <I>user_name</I> | <I>user_group</I> ...
<!-- .SS Description -->
</BLOCKQUOTE>
<A name=148>

    <H4>&nbsp; &nbsp; Description</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
A list of users or user groups that can submit jobs to this queue
<!-- .PP -->
<P>
Use the reserved word all to specify all openlava users.
<!-- .PP -->
<P>
openlava cluster administrators can submit jobs to this queue
or switch any user&#146;s jobs into this queue, even if they are not listed.
<!-- .SS Default -->
</BLOCKQUOTE>
<A name=149>

    <H4>&nbsp; &nbsp; Default</H4>
</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
all
<!-- .SH SEE ALSO -->
</BLOCKQUOTE>
<A name=150>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
lsf.cluster(5), lsf.conf(5), lsb.params(5),
lsb.hosts(5), lsb.users(5), 
busers(1), bugroup(1), bchkpnt(1), nice(1), getgrnam(3),
getrlimit(2), bmgroup(1), bqueues(1), bhosts(1),
bsub(1), lsid(1), mbatchd(8), badmin(8)
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>lsb.queues (5)</TD> <TD align=right width=33%><I>"openlava Version 2.0 - Jan 2012"</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.07</A> from lsb.queues.5 using man macros.</FONT>
</BODY></HTML>

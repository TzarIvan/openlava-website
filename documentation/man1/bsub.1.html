<HTML><HEAD>
<TITLE>bsub.1</TITLE>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!-- .ds ]W % -->
<!-- .ds ]L -->
<!-- .nh -->
<!-- ignored unsupported tag .nh -->
<!-- .TH bsub 1 "openlava Version 2.0 - Jan 2012" -->
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>bsub (1)</NOBR><HR></H1>
</CENTER>
<!-- .br -->
<!-- .SH NAME -->
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>bsub</B> - submits a batch job to openlava
<!-- .SH SYNOPSIS -->
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Option List</A><BR>
<A HREF=#3>Description</A><BR>
<A HREF=#4>Options</A><BR>
<A HREF=#5>Output</A><BR>
<A HREF=#6>Examples</A><BR>
<A HREF=#7>Limitations</A><BR>
<A HREF=#8>See Also</A><BR>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<B>bsub </B>[<I>options</I>] <I>command </I>[<I>arguments</I>]
<!-- .br -->
<!-- Need break --><BR>
<B>bsub </B>[<B>-h</B> | <B>-V</B>]
<!-- .SH OPTION LIST -->
</BLOCKQUOTE>
<A name=2>

     <H3>OPTION LIST</H3>

</A>
<BLOCKQUOTE>
<B>-B</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-H</B>
<!-- .br -->
<!-- Need break --><BR>
[<B>-I</B> | <B>-Ip</B> | <B>-Is</B> | <B>-K</B>]
<!-- .br -->
<!-- Need break --><BR>
<B>-N</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-r</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-x</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-a</B> <I>esub_parameters</I>
<!-- .br -->
<!-- Need break --><BR>
<B>-b </B>[[<I>month</I><B>:</B>]<I>day</I><B>:</B>]<I>hour</I><B>:</B>minute
<!-- .br -->
<!-- Need break --><BR>
<B>-C</B> <I>core_limit</I>
<!-- .br -->
<!-- Need break --><BR>
<B>-c</B> [<I>hours</I><B>:</B>]<I>minutes</I>[<B>/</B>host_name | <B>/</B>host_model]
<!-- .br -->
<!-- Need break --><BR>
<B>-D</B> data_limit
<!-- .br -->
<!-- Need break --><BR>
<B>-e </B>err_file
<!-- .br -->
<!-- Need break --><BR>
<B>-E "</B>pre_exec_command [<I>argument </I>...]<B>"</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-f </B> <B>"</B>local_file op [<I>remote_file</I>]<B>" </B>...
<!-- .br -->
<!-- Need break --><BR>
<B>-F </B>file_limit
<!-- .br -->
<!-- Need break --><BR>
[<B>-i </B>i<I>nput_file</I> | <B>-is</B> <I>input_file</I>]
<!-- .br -->
<!-- Need break --><BR>
<B>-J</B> <I>job_name | </I><B>-J</B>  <B>"</B>job_name<B>[</B>index_list<B>]%</B>job_limit<B>"</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-k "</B>checkpoint_dir [<I>checkpoint_period</I>] [<B>method=</B>method_name]<B>"</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-L</B> login_shell
<!-- .br -->
<!-- Need break --><BR>
<B>-m</B> <B>"</B>host_name[<B>+</B>[<I>pref_level</I>]] | <I>host_group</I>[<B>+</B>[<I>pref_level</I>]] ...<B>"</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-M</B> <I>mem_limit</I>
<!-- .br -->
<!-- Need break --><BR>
<B>-n </B>min_processors[<B>,</B>max_processors]
<!-- .br -->
<!-- Need break --><BR>
<B>-o</B> out_file
<!-- .br -->
<!-- Need break --><BR>
<B>-P</B> project_name
<!-- .br -->
<!-- Need break --><BR>
<B>-q</B> <B>"</B>queue_name ...<B>"</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-R</B> <B>"</B>res_req<B>"</B>
<!-- .br -->
<!-- Need break --><BR>
-<B>sp</B> <I>priority</I>
<!-- .br -->
<!-- Need break --><BR>
<B>-S </B>stack_limit
<!-- .br -->
<!-- Need break --><BR>
<B>-t </B>[[<I>month</I><B>:</B>]<I>day</I><B>:</B>]<I>hour</I><B>:</B>minute
<!-- .br -->
<!-- Need break --><BR>
<B>-u</B> <I>mail_user</I>
<!-- .br -->
<!-- Need break --><BR>
<B>-v</B> <I>swap_limit</I>
<!-- .br -->
<!-- Need break --><BR>
<B>-w</B> <B>&#146;</B>dependency_expression<B>&#146;</B>
<!-- .br -->
<!-- Need break --><BR>
<B>-W </B>[<I>hours</I><B>:</B>]<I>minutes</I>[<B>/</B>host_name | <B>/</B>host_model]
<!-- .br -->
<!-- Need break --><BR>
<B>-Zs</B>
<!-- .SH DESCRIPTION -->
</BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
Submits a job for batch execution and assigns it a unique numerical job
ID.
<!-- .PP -->
<P>
Runs the job on a host that satisfies all requirements of the job, when
all conditions on the job, host, queue, and cluster are satisfied. If openlava
cannot run all jobs immediately, openlava scheduling policies determine the
order of dispatch. Jobs are started and suspended according to the
current system load.
<!-- .PP -->
<P>
Sets the user&#146;s execution environment for the job, including the current
working directory, file creation mask, and all environment variables,
and sets openlava environment variables before starting the job.
<!-- .PP -->
<P>
When a job is run, the command line and stdout/stderr buffers are
stored in the directory home_directory/.lsbatch on the execution
host. If this directory is not accessible, /tmp/.lsbtmpuser_ID is used
as the job&#146;s home directory. If the current working directory is under
the home directory on the submission host, then the current working
directory is also set to be the same relative directory under the home
directory on the execution host. The job is run in /tmp if the current
working directory is not accessible on the execution host.
<!-- .PP -->
<P>
If no command is supplied for <B>bsub</B>, <B>bsub</B> prompts for the command
from the standard input. On LINUX, the input is terminated by entering
CTRL-D on a new line.
<!-- .PP -->
<P>
By default, openlava assumes that uniform user names and user ID spaces
exist among all the hosts in the cluster. That is, a job submitted by a
given user will run under the same user&#146;s account on the execution
host. For situations where nonuniform user names and user ID spaces
exist, account mapping must be used to determine the account used to
run a job.
<!-- .PP -->
<P>
By default, uses the command name as the job name. Quotation marks
are significant.
<!-- .PP -->
<P>
By default, the job is not checkpointable.
<!-- .PP -->
<P>
By default, automatically selects an appropriate queue. If you defined
a default queue list by setting LSB_DEFAULTQUEUE, the queue is
selected from your list. If LSB_DEFAULTQUEUE is not defined, the
queue is selected from the system default queue list specified by the
openlava administrator (see the parameter DEFAULT_QUEUE in
lsb.params(5)).
<!-- .PP -->
<P>
By default, openlava tries to obtain resource requirement information for the
job from the remote task list that is maintained by the load sharing
library (see <B>lsfintro</B>(1)). If the job is not listed in the remote task list,
the default resource requirement is to run the job on a host or hosts
that are of the same host type (see <B>lshosts</B>(1)) as the submission host.
<!-- .PP -->
<P>
By default, assumes only one processor is requested.
<!-- .PP -->
<P>
By default, does not start a login shell but runs the job file under the
execution environment from which the job was submitted.
<!-- .PP -->
<P>
By default, the input file for the batch job is /dev/null (no input).
<!-- .PP -->
<P>
By default, sends mail to you when the job is done. The default
destination is defined by LSB_MAILTO in lsf.conf. The mail message
includes the job report, the job output (if any), and the error message
(if any).
<!-- .PP -->
<P>
By default, charges the job to the default project. The default project is
the project you define by setting the environment variable
LSB_DEFAULTPROJECT. If you do not set LSB_DEFAULTPROJECT, the
default project is the project specified by the openlava administrator in the
lsb.params configuration file (see the DEFAULT_PROJECT parameter
in lsb.params(5)). If DEFAULT_PROJECT is not defined, then openlava
uses default as the default project name.
<!-- .PP -->
<P>
Use <B>-n</B> to submit a parallel job.
<!-- .PP -->
<P>
Use <B>-I</B>, <B>-Is</B>, or <B>-Ip</B> to submit a batch interactive job.
<!-- .PP -->
<P>
Use <B>-J</B> to assign a name to your job.
<!-- .PP -->
<P>
Use <B>-k</B> to specify a checkpointable job.
<!-- .PP -->
<P>
To kill a batch job submitted with <B>bsub</B>, use <B>bkill</B>.
<!-- .PP -->
<P>
Use <B>bmod</B> to modify jobs submitted with <B>bsub</B>. <B>bmod</B> takes similar
options to <B>bsub</B>.
<!-- .SH OPTIONS -->
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .TP  -->
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>-B
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sends mail to you when the job is dispatched and begins execution.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-H
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Holds the job in the PSUSP state when the job is submitted. The job
will not be scheduled until you tell the system to resume the job (see<B>
bresume</B>(1)).
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-I</B> | <B>-Ip</B> | <B>-Is
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Submits a batch interactive job. A new job cannot be submitted until
the interactive job is completed or terminated.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sends the job&#146;s standard output (or standard error) to the terminal.
Does not send mail to you when the job is done unless you specify the
<B>-N</B> option.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Terminal support is available for a batch interactive job.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
When you specify the <B>-Ip</B> option, submits a batch interactive job and
creates a pseudo-terminal when the job starts. Some applications (for
example, <B>vi</B>) require a pseudo-terminal in order to run correctly.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
When you specify the <B>-Is</B> option, submits a batch interactive job and
creates a pseudo-terminal with shell mode support when the job starts.
This option should be specified for submitting interactive shells, or
applications which redefine the CTRL-C and CTRL-Z keys (for example,
jove).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the <B>-i</B> <I>input_file </I>option is specified, you cannot interact with the
job&#146;s standard input via the terminal.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the <B>-o</B> <I>out_file</I> option is specified, sends the job&#146;s standard output to
the specified output file. If the <B>-e</B> <I>err_file</I> option is specified, sends the
job&#146;s standard error to the specified error file<I>.</I>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
You cannot use <B>-I</B>, <B>-Ip</B>, or <B>-Is</B> with the <B>-K</B> option.
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-K
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Submits a batch job and waits for the job to complete. Sends the
message "Waiting for dispatch" to the terminal when you submit
the job. Sends the message "Job is finished" to the terminal when
the job is done.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
You will not be able to submit another job until the job is completed.
This is useful when completion of the job is required in order to
proceed, such as a job script. If the job needs to be rerun due to
transient failures, <B>bsub</B> returns after the job finishes successfully. <B>bsub</B>
will exit with the same exit code as the job so that job scripts can take
appropriate actions based on the exit codes. <B>bsub</B> exits with value 126
if the job was terminated while pending.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
You cannot use the <B>-K</B> option with the <B>-I</B>, <B>-Ip</B>, or <B>-Is</B> options.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-N
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sends the job report to you by mail when the job finishes. When used
without any other options, behaves the same as the default.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Use only with <B>-o</B>, <B>-I</B>, <B>-Ip</B>, and <B>-Is</B> options, which do not send mail,
to force openlava to send you a mail message when the job is done.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-r
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the execution host becomes unavailable while a job is running,
specifies that the job will rerun on another host. openlava requeues the job
in the same job queue with the same job ID. When an available
execution host is found, reruns the job as if it were submitted new. You
receive a mail message informing you of the host failure and requeuing
of the job.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the system goes down while a job is running, specifies that the job
will be requeued when the system restarts.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Reruns a job if the execution host or the system fails; it does not rerun
a job if the job itself fails.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the execution host becomes unavailable after a job has been
checkpointed (see <B>bsub -k</B> and <B>bchkpnt</B>(1)), the job is restarted from
the last checkpoint. The restarted job is requeued for execution in the
same way that you would restart a job using <B>brestart</B>(1). In order for
the job to be successfully restarted, the job&#146;s checkpoint directory must
reside in a shared file system accessible to the host receiving the
restarted job.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-x
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Puts the host running your job into exclusive execution mode.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
In exclusive execution mode, your job runs by itself on a host. It is
dispatched only to a host with no other jobs running, and openlava does not
send any other jobs to the host until the job completes.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
To submit a job in exclusive execution mode, the queue must be
configured to allow exclusive jobs.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
When the job is dispatched, <B>bhosts</B>(1) reports the host status as
closed_Excl, and <B>lsload</B>(1) reports the host status as lockU.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Until your job is complete, the host is not selected by LIM in response
to placement requests made by <B>lsplace</B>(1) or
any other load sharing applications.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
You can force other batch jobs to run on the host by using the <B>-m</B>
<I>host_name</I> option of <B>brun</B>(1) to explicitly specify the locked host.
<P>
<!-- .TP -->
</TD></TR>
<TR valign=top><TD colspan=2>
<!-- Suppressing TP body due to .IP -->
<B>-a </B><I>esub_parameters</I>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The parameter is stored as <B>LSB_SUB_ADDITIONAL</B> in the parameter file of
the job (i.e. <B>LSB_SUB_PARM_FILE</B>). This file can be read by an <B>esub</B>.
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-b </B>[[<I>month</I><B>:</B>]<I>day</I><B>:</B>]<I>hour</I><B>:</B>minute
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Dispatches the job for execution on or after the specified date and time.
The date and time are in the form of [[month:]day:]hour:minute where
the number ranges are as follows: month 1-12, day 1-31, hour 0-23,
minute 0-59.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
At least two fields must be specified. These fields are assumed to be
hour:minute. If three fields are given, they are assumed to be
day:hour:minute, and four fields are assumed to be
month:day:hour:minute.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-C</B> core_limit
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sets a per-process (soft) core file size limit for all the processes that
belong to this batch job (see <B>getrlimit</B>(2)). The core limit is specified
in kilobytes.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The behavior of this option depends on platform-specific LINUX
systems.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
In some cases, the process is sent a SIGXFSZ signal if the job attempts
to create a core file larger than the specified limit. The SIGXFSZ signal
normally terminates the process.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
In other cases, the writing of the core file terminates at the specified
limit.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-c</B> [hours<B>:</B>]minutes[<B>/</B>host_name | <B>/</B>host_model]
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Limits the total CPU time the job can use. This option is useful for
preventing runaway jobs or jobs that use up too many resources. When
the total CPU time for the whole job has reached the limit, a SIGXCPU
signal is first sent to the job, then SIGINT, SIGTERM, and SIGKILL.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If LSB_JOB_CPULIMIT in lsf.conf is set to n, openlava-enforced CPU limit
is disabled and openlava passes the limit to the operating system. When one
process in the job exceeds the CPU limit, the limit is enforced by the
operating system.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The CPU limit is in the form of [hours<B>:</B>]minutes. The minutes can be
specified as a number greater than 59. For example, three and a half
hours can either be specified as 3:30, or 210.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Optionally, you can supply a host name or a host model name defined
in openlava. You must insert &#145;/&#146; between the CPU limit and the host name or
model name. (See <B>lsinfo</B>(1) to get host model information.) If a host
name or model name is not given, openlava uses the default CPU time
normalization host defined at the queue level (DEFAULT_HOST_SPEC
in lsb.queues) if it has been configured, otherwise uses the default
CPU time normalization host defined at the cluster level
(DEFAULT_HOST_SPEC in lsb.params) if it has been configured,
otherwise uses the submission host.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The CPU time you specify is the normalized CPU time. This is done so
that the job does approximately the same amount of processing for a
given CPU limit, even if it is sent to host with a faster or slower CPU.
Whenever a normalized CPU time is given, the actual time on the
execution host is the specified time multiplied by the CPU factor of the
normalization host then divided by the CPU factor of the execution
host.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-D </B>data_limit
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sets a per-process (soft) data segment size limit for each of the
processes that belong to the batch job (see <B>getrlimit</B>(2)). The data
limit is specified in kilobytes. A <B>sbrk</B> call to extend the data segment
beyond the data limit will return an error.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-e</B> err_file
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Specify a file path. Appends the standard error output of the job to the
specified file.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use the special character %J in the name of the error file, then
%J is replaced by the job ID of the job. If you use the special character
%I in the name of the error file, then %I is replaced by the index of the
job in the array if the job is a member of an array. Otherwise, %I is
replaced by 0 (zero).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the current working directory is not accessible on the execution host
after the job starts, openlava writes the standard error output file to /tmp/.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-E</B> <B>"</B>pre_exec_command [arguments ...]<B>"</B>
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Runs the specified pre-exec command on the batch job&#146;s execution
host before actually running the job. For a parallel job, the pre-exec
command runs on the first host selected for the parallel job. If the pre-
exec command exits with 0 (zero), then the real job is started on the
selected host. Otherwise, the job (including the pre-exec command)
goes back to PEND status and is rescheduled.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If your job goes back into PEND status, openlava will keep on trying to run
the pre-exec command and the real job when conditions permit. For
this reason, be sure that your pre-exec command can be run many
times without having side effects.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The standard input and output for the pre-exec command are directed
to the same files as for the real job. The pre-exec command runs under
the same user ID, environment, home, and working directory as the
real job. If the pre-exec command is not in the user&#146;s normal execution
path (the $PATH variable), the full path name of the command must be
specified.
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-f</B> <B>"</B>local_file op [remote_file]<B>"</B> ...
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Copies a file between the local (submission) host and the remote
(execution) host. Specify absolute or relative paths, including the file
names. You should specify the remote file as a file name with no path
when running in non-shared systems.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the remote file is not specified, it defaults to the local file, which must
be given. Use multiple <B>-f</B> options to specify multiple files.
<P>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<I>op</I>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <I>op</I>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
An operator that specifies whether the file is copied to the
remote host, or whether it is copied back from the remote host.
The operator must be surrounded by white space.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The following describes the operators:
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&gt; Copies the local file to the remote file before the job starts.
Overwrites the remote file if it exists.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&lt; Copies the remote file to the local file after the job completes.
Overwrites the local file if it exists.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&lt;&lt; Appends the remote file to the local file after the job
completes. The local file must exist.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&gt;&lt; Copies the local file to the remote file before the job starts.
Overwrites the remote file if it exists. Then copies the remote
file to the local file after the job completes. Overwrites the local
file.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&lt;&gt; Copies the local file to the remote file before the job starts.
Overwrites the remote file if it exists. Then copies the remote
file to the local file after the job completes. Overwrites the local
file.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use the <B>-i</B> <I>input_file </I>option, then you do not have to use the <B>-f</B>
option to copy the specified input file to the execution host. openlava does
this for you, and removes the input file from the execution host after
the job completes.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use the <B>-e</B> <I>err_file</I> or the <B>-o</B> <I>out_file</I> option, and you want the
specified file to be copied back to the submission host when the job
completes, then you must use the <B>-f</B> option.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the submission and execution hosts have different directory
structures, you must ensure that the directory where the remote file and
local file will be placed exists.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the local and remote hosts have different file name spaces, you must
always specify relative path names. If the local and remote hosts do not
share the same file system, you must ensure that the directory
containing the remote file exists. It is recommended that only the file
name be given for the remote file when running in heterogeneous file
systems. This places the file in the job&#146;s current working directory. If
the file is shared between the submission and execution hosts, then no
file copy is performed.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
openlava uses <B>lsrcp</B> to transfer files (see <B>lsrcp</B>(1) command). <B>lsrcp</B>
contacts RES on the remote host to perform the file transfer. If RES is
not available, <B>rcp</B> is used (see <B>rcp</B>(1)). The user must ensure that the
<B>rcp</B> binary is in the user&#146;s $PATH on the execution host.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Jobs that are submitted from openlava client hosts should specify the <B>-f</B>
option only if <B>rcp</B> is allowed. Similarly, <B>rcp</B> must be allowed if account
mapping is used.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-F</B> file_limit
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sets a per-process (soft) file size limit for each of the processes that
belong to the batch job (see <B>getrlimit</B>(2)). The file size limit is
specified in kilobytes. If a job process attempts to write to a file that
exceeds the file size limit, then that process is sent a SIGXFSZ signal.
The SIGXFSZ signal normally terminates the process.
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-i </B>input_file | <B>-is</B> input_file
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Gets the standard input for the job from specified file. Specify an
absolute or relative path. The input file can be any type of file, though
it is typically a shell script text file.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the file exists on the execution host, openlava uses it. Otherwise, openlava
attempts to copy the file from the submission host to the execution
host. For the file copy to be successful, you must allow remote copy
(<B>rcp</B>) access, or you must submit the job from a server host where RES
is running. The file is copied from the submission host to a temporary
file in the directory specified by the JOB_SPOOL_DIR parameter, or
your $HOME/.lsbatch directory on the execution host. openlava removes
this file when the job completes.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The <B>-is</B> option spools the input file to the directory specified by the
JOB_SPOOL_DIR parameter in lsb.params, and uses the spooled file
as the input file for the job. By default, if JOB_SPOOL_DIR is not
specified, the input file is spooled to
LSB_SHAREDIR/cluster_name/lsf_indir. If the lsf_indir directory
does not exist, openlava creates it before spooling the file. openlava removes the
spooled file when the job completes. Use the <B>-is</B> option if you need
to modify or remove the input file before the job completes. Removing
or modifying the original input file does not affect the submitted job.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Unless you use <B>-is</B>, you can use the special characters %J and %I in
the name of the input file. %J is replaced by the job ID. %I is replaced
by the index of the job in the array, if the job is a member of an array,
otherwise by 0 (zero). The special characters %J and %I are not valid
with the <B>-is</B> option.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-J</B> job_name
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<!-- .br -->
<B>-J</B> <B>"</B>job_name<B>[</B>index<I>_list</I><B>]%</B>job_slot_limit<B>"
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Assigns the specified name to the job, and, for job arrays, specifies the
indices of the job array and optionally the maximum number of jobs
that can run at any given time.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job name need not be unique.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
To specify a job array, enclose the index list in square brackets, as
shown, and enclose the entire job array specification in quotation
marks, as shown. The index list is a comma-separated list whose
elements have the syntax start[-end[<B>:</B>step]] where start, end and step are
positive integers. If the step is omitted, a step of one is assumed. The
job array index starts at one. By default, the maximum job array index
is 2.00.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
You may also use a positive integer to specify the system-wide job slot
limit (the maximum number of jobs that can run at any given time) for
this job array.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
All jobs in the array share the same job ID and parameters. Each
element of the array is distinguished by its array index.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
After a job is submitted, you use the job name to identify the job.
Specify <B>"</B>job_ID<B>[</B>index<B>]"</B> to<B> </B>work with elements of a particular array.
Specify <B>"</B>job_name<B>[</B>index<B>]"</B> to work with elements of all arrays with the
same name. Since job names are not unique, multiple job arrays may
have the same name with a different or same set of indices.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-k "</B>checkpoint_dir [checkpoint_period][<B>method=</B>method_name]<B>"
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Makes a job checkpointable and specifies the checkpoint directory. If
you omit the checkpoint period, the quotes are not required. Specify a
relative or absolute path name.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
When a job is checkpointed, the checkpoint information is stored in
<I>checkpoint_dir</I>/<I>job_ID</I>/<I>file_name</I>. Multiple jobs can checkpoint into
the same directory. The system can create multiple files.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The checkpoint directory is used for restarting the job (see
<B>brestart</B>(1)).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Optionally, specifies a checkpoint period in minutes. Specify a positive
integer. The running job is checkpointed automatically every
checkpoint period. The checkpoint period can be changed using
<B>bchkpnt</B>(1). Because checkpointing is a heavyweight operation, you
should choose a checkpoint period greater than half an hour.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Optionally, specifies a custom checkpoint and restart method to use
with the job. Use <B>method=default</B> to indicate to use openlava&#146;s default
checkpoint and restart programs for the job, echkpnt.default and
erestart.default.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The echkpnt.method_name and erestart.method_name programs
must be in LSF_SERVERDIR or in the directory specified by
LSB_ECHKPNT_METHOD_DIR (environment variable or set in
lsf.conf).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If a custom checkpoint and restart method is already specified with
LSB_ECHKPNT_METHOD (environment variable or in lsf.conf), the
method you specify with bsub -k overrides this.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Process checkpointing is not available on all host types, and may
require linking programs with a special libraries (see <B>libckpt.a</B>(3)).
openlava invokes <B>echkpnt</B> (see <B>echkpnt</B>(8)) found in LSF_SERVERDIR to
checkpoint the job. You can override the default <B>echkpnt</B> for the job
by defining as environment variables or in lsf.conf
LSB_ECHKPNT_METHOD and LSB_ECHKPNT_METHOD_DIR to point
to your own <B>echkpnt</B>. This allows you to use other checkpointing
facilities, including application-level checkpointing.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
-<B>L</B> login_shell
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Initializes the execution environment using the specified login shell.
The specified login shell must be an absolute path. This is not
necessarily the shell under which the job will be executed.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-m</B> <B>"</B>host_name[<B>+</B>[pref_level]] | host_group[<B>+</B>[pref_level]] ...<B>"
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Runs the job on one of the specified hosts.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
By default, if multiple hosts are candidates, runs the job on the least-
loaded host. To change this, put a plus (+) after the names of hosts or
host groups that you would prefer to use, optionally followed by a
preference level. For preference level, specify a positive integer, with
higher numbers indicating greater preferences for those hosts.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For example, -m "hostA groupB+2 hostC+1" indicates that groupB
is the most preferred and hostA is the least preferred.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For information about host groups, use <B>bmgroup</B>.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The keyword others can be specified with or without a preference
level to refer to other hosts not otherwise listed. The keyword others
must be specified with at least one host name or host group, it cannot
be specified by itself. For example, -m "hostA+ others" means that
hostA is preferred over all other hosts.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use both the <B>-m "</B><I>host_name</I>[+[<I>pref_level</I>]] |
<I>host_group</I>[+[<I>pref_level</I>]]..." option and the <B>-q</B> <I>queue_name</I>
option, the specified queue must be configured to include all the hosts
in the your host list. Otherwise, the job is not submitted. To find out
what hosts are configured for the queue, use <B>bqueues -l</B>.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-M</B> mem_limit
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Specify the memory limit, in kilobytes.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If LSB_MEMLIMIT_ENFORCE or LSB_JOB_MEMLIMIT are set to y in
lsf.conf, openlava kills the job when it exceeds the memory limit.
Otherwise, openlava passes the memory limit to the operating system. UNIX
operating systems that support RUSAGE_RSS for <B>setrlimit()</B> can
apply the memory limit to each process.
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-n</B> min_proc[<B>,</B>max_proc]
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Submits a parallel job and specifies the minimum and maximum
numbers of processors required to run the job (some of the processors
may be on the same multiprocessor host). If you do not specify a
maximum, the number you specify represents the exact number of
processors to use.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the maximum number of processors is greater than the process limit
of the queue to which the job is submitted, openlava will reject the job (see
the PROCLIMIT parameter in lsb.queues(5)).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Once at least the minimum number of processors is available, the job
is dispatched to the first host selected. The list of selected host names
for the job are specified in the environment variables LSB_HOSTS and
LSB_MCPU_HOSTS. The job itself is expected to start parallel
components on these hosts and establish communication among them,
optionally using RES.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-o</B> out_file
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Specify a file path. Appends the standard output of the job to the
specified file. Sends the output by mail if the file does not exist, or the
system has trouble writing to it.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If only a file name is specified, openlava writes the output file to the current
working directory. If the current working directory is not accessible on
the execution host after the job starts, openlava writes the standard output
file to /tmp/.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use <B>-o</B> without <B>-e</B>, the standard error of the job is stored in the
output file.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use <B>-o</B> without <B>-N</B>, the job report is stored in the output file as
the file header.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use both <B>-o</B> and <B>-N</B>, the output is stored in the output file and
the job report is sent by mail. The job report itself does not contain the
output, but the report will advise you where to find your output.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you use the special character %J in the name of the output file, then
%J is replaced by the job ID of the job. If you use the special character
%I in the name of the output file, then %I is replaced by the index of
the job in the array, if the job is a member of an array. Otherwise, %I
is replaced by 0 (zero).
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-P</B> project_name
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Assigns the job to the specified project.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-p</B> process_limit
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sets the limit of the number of processes to <I>process_limit</I> for the whole
job. The default is no limit. Exceeding the limit causes the job to
terminate.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-q</B> <B>"</B>queue_name ...<B>"
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Submits the job to one of the specified queues. Quotes are optional for
a single queue. For a list of available queues, use <B>bqueues</B>.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
When a list of queue names is specified, openlava selects the most
appropriate queue in the list for your job based on the job&#146;s resource
limits, and other restrictions, such as the requested hosts, your
accessibility to a queue, queue status (closed or open), whether a
queue can accept exclusive jobs, etc. The order in which the queues
are considered is the same order in which these queues are listed. The
queue listed first is considered first.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-R "</B>res_req<B>"</B>
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Runs the job on a host that meets the specified resource requirements.
Specify the resource requirement string as usual. The size of the
resource requirement string is limited to 512 bytes.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Any run-queue-length-specific resource, such as r15s, r1m or r15m,
specified in the resource requirements refers to the normalized run
queue length.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
-<B>sp</B> priority
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Specifies user-assigned job priority which allow users to order their
jobs in a queue. Valid values for priority are any integers between 1
and MAX_USER_PRIORITY (displayed by <B>bparams -l</B>). Incorrect job
priorities are rejected. openlava and queue administrators can specify
priorities beyond MAX_USER_PRIORITY.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job owner can change the priority of their own jobs. openlava and
queue administrators can change the priority of all jobs in a queue.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Job order is the first consideration to determine job eligibility for
dispatch. Jobs are still subject to all scheduling policies regardless of
job priority. Jobs with the same priority are ordered first come first
served.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
User-assigned job priority can be configured with automatic job priority
escalation to automatically increase the priority of jobs that have been
pending for a specified period of time.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-S</B> stack_limit
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sets a per-process (soft) stack segment size limit (KB) for each of the
processes that belong to the batch job (see <B>getrlimit</B>(2)).
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-t </B>[[<I>month</I><B>:</B>]<I>day</I><B>:</B>]<I>hour</I><B>:</B>minute
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Specifies the job termination deadline. If a LINUX job is still running at
the termination time, the job is sent a SIGUSR2 signal, and is killed if it
does not terminate within ten minutes.
(For a detailed description of how these jobs are killed, see <B>bkill</B>.) In the queue
definition, a TERMINATE action can be configured to override the
<B>bkill</B> default action (see the JOB_CONTROLS parameter in
lsb.queues(5)).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The format for the termination time is [[month:]day:]hour:minute where
the number ranges are as follows: month 1-12, day 1-31, hour 0-23,
minute 0-59.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
At least two fields must be specified. These fields are assumed to be
hour:minute. If three fields are given, they are assumed to be
day:hour:minute, and four fields are assumed to be
month:day:hour:minute.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-u</B> mail_user
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sends mail to the specified email destination.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-v</B> swap_limit
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Set the total process virtual memory limit to <I>swap_limit</I> in KB for the
whole job. The default is no limit. Exceeding the limit causes the job
to terminate.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-w</B> <B>&#146;</B>dependency_expression<B>&#146;
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
openlava will not place your job unless the dependency expression evaluates
to TRUE. If you specify a dependency on a job that openlava cannot find
(such as a job that has not yet been submitted), your job submission
fails.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The dependency expression is a logical expression composed of one
or more dependency conditions. To make dependency expression of
multiple conditions, use the following logical operators:
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&& (AND)
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
|| (OR)
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
! (NOT)
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Use parentheses to indicate the order of operations, if necessary.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Enclose the dependency expression in single quotes (&#146;) to prevent the
shell from interpreting special characters (space, any logic operator, or
parentheses). If you use single quotes for the dependency expression,
use double quotes for quoted items within it, such as job names.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
In dependency conditions, job names specify only your own jobs,
unless you are an openlava administrator. By default, if you use the job name
to specify a dependency condition, and more than one of your jobs has
the same name, all of your jobs that have that name must satisfy the
test. If JOB_DEP_LAST_SUB in lsb.params is set to 1, the test is done
on the job submitted most recently. Use double quotes (") around job
names that begin with a number. In the job name, specify the wildcard
character asterisk (*) at the end of a string, to indicate all jobs whose
name begins with the string. For example, if you use jobA* as the job
name, it specifies jobs named jobA, jobA1, jobA_test, jobA.log,
etc.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Use the * with dependency conditions to define one-to-one
dependency among job array elements such that each element of one
array depends on the corresponding element of another array. The job
array size must be identical. For example, bsub <B>-w
"done(myarrayA[*])"</B> -J "myArrayB[1-10]" myJob2 indicates that
before element 1 of myArrayB can start, element 1 of myArrayA must be
completed, and so on.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
You can also use the * to establish one-to-one array element
dependencies with bmod after an array has been submitted.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you want to specify array dependency by array name, set
JOB_DEP_LAST_SUB in lsb.params. If you do not have this
parameter set, the job will be rejected if one of your previous arrays
has the same name but a different index.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
In dependency conditions, the variable <I>op</I> represents one of the
following relational operators:
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&gt;
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&gt;=
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&lt;
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
&lt;=
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
==
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
!=
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Use the following conditions to form the dependency expression.
<P>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>done(</B>job_ID |<B>"</B>job_name<B>"</B> ...<B>)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>done(</B>job_ID |<B>"</B>job_name<B>"</B> ...<B>)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job state is DONE.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
openlava refers to the oldest job of <I>job_name</I> in memory.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>ended(</B>job_ID | <B>"</B>job_name<B>")</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>ended(</B>job_ID | <B>"</B>job_name<B>")</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job state is EXIT or DONE.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>exit(</B>job_ID | <B>"</B>job_name<B>"</B> [<B>,</B>[op] exit_code]<B>)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>exit(</B>job_ID | <B>"</B>job_name<B>"</B> [<B>,</B>[op] exit_code]<B>)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job state is EXIT, and the job&#146;s exit code satisfies the
comparison test.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you specify an exit code with no operator, the test is for
equality (== is assumed).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you specify only the job, any exit code satisfies the test.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>external(</B>job_ID | <B>"</B>job_name<B>",</B> <B>"</B>status_text<B>")</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>external(</B>job_ID | <B>"</B>job_name<B>",</B> <B>"</B>status_text<B>")</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Specify the first word of the job status or message description
(no spaces). Only the first word is evaluated.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job has the specified job status, or the text of the job&#146;s
status begins with the specified word.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
job_ID | <B>"</B>job_name<B>"</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: job_ID | <B>"</B>job_name<B>"</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If you specify a job without a dependency condition, the test is
for the DONE state (openlava assumes the "done" dependency
condition by default).
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>numdone(</B>job_ID, op number | <B>*)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>numdone(</B>job_ID, op number | <B>*)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For a job array, the number of jobs in the DONE state satisfies
the test. Use * (with no operator) to specify all the jobs in the
array.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>numended(</B>job_ID, op number | <B>*)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>numended(</B>job_ID, op number | <B>*)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For a job array, the number of jobs in the DONE or EXIT states
satisfies the test. Use * (with no operator) to specify all the jobs
in the array.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>numexit(</B>job_ID<I>,</I> op number | <B>*)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>numexit(</B>job_ID<I>,</I> op number | <B>*)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For a job array, the number of jobs in the EXIT state satisfies
the test. Use * (with no operator) to specify all the jobs in the
array.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>numhold(</B>job_ID<I>,</I> op number | <B>*)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>numhold(</B>job_ID<I>,</I> op number | <B>*)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For a job array, the number of jobs in the PSUSP state satisfies
the test. Use * (with no operator) to specify all the jobs in the
array.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>numpend(</B>job_ID<I>,</I> op number | <B>*)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>numpend(</B>job_ID<I>,</I> op number | <B>*)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For a job array, the number of jobs in the PEND state satisfies
the test. Use * (with no operator) to specify all the jobs in the
array.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>numrun(</B>job_ID<I>,</I> op number | <B>*)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>numrun(</B>job_ID<I>,</I> op number | <B>*)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For a job array, the number of jobs in the RUN state satisfies the
test. Use * (with no operator) to specify all the jobs in the array.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>numstart(</B>job_ID<I>,</I> op number | <B>*)</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>numstart(</B>job_ID<I>,</I> op number | <B>*)</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
For a job array, the number of jobs in the RUN, USUSP, or
SSUSP states satisfies the test. Use * (with no operator) to
specify all the jobs in the array.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>post_done(</B>job_ID | <B>"</B>job_name<B>")</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>post_done(</B>job_ID | <B>"</B>job_name<B>")</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job state is POST_DONE (the post-processing of specified
job has completed without errors).
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>post_err(</B>job_ID | <B>"</B>job_name<B>")</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>post_err(</B>job_ID | <B>"</B>job_name<B>")</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job state is POST_ERR (the post-processing of the specified
job has completed with errors).
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
<B>started(</B>job_ID | <B>"</B>job_name<B>")</B>
<!-- .BR -->
 <!-- .RS -->
<!-- .IP -->
<TABLE width=100% cellpadding=3><!-- tsb: <B>started(</B>job_ID | <B>"</B>job_name<B>")</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job state is:
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
- RUN, DONE, or EXIT
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
- PEND or PSUSP, and the job has a pre-execution command
(bsub -E) that is running.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
<B>-W</B> [hours<B>:</B>]minutes[<B>/</B>host_name | <B>/</B>host_model]
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Sets the run time limit of the batch job. If a LINUX job runs longer than
the specified run limit, the job is sent a SIGUSR2 signal, and is killed if
it does not terminate within ten minutes.  (For a detailed
description of how these jobs are killed, see <B>bkill</B>.) In the queue
definition, a TERMINATE action can be configured to override the
<B>bkill</B> default action (see the JOB_CONTROLS parameter in
lsb.queues(5)).
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The run limit is in the form of [hours<B>:</B>]minutes. The minutes can be
specified as a number greater than 59. For example, three and a half
hours can either be specified as 3:30, or 210.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Optionally, you can supply a host name or a host model name defined
in openlava. You must insert "/" between the run limit and the host name
or model name. (See <B>lsinfo</B>(1) to get host model information.) If a
host name or model name is not given, openlava uses the default CPU time
normalization host defined at the queue level (DEFAULT_HOST_SPEC
in lsb.queues) if it has been configured, otherwise uses the default
CPU time normalization host defined at the cluster level
(DEFAULT_HOST_SPEC in lsb.params) if it has been configured,
otherwise uses the submission host.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The CPU time you specify is the normalized CPU time. This is done so
that the job does approximately the same amount of processing, even
if it is sent to host with a faster or slower CPU. Whenever a normalized
CPU time is given, the actual time on the execution host is the specified
time multiplied by the CPU factor of the normalization host then
divided by the CPU factor of the execution host.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the job also has termination time specified through the <B>bsub -t</B>
option, openlava determines whether the job can actually run for the
specified length of time allowed by the run limit before the termination
time. If not, then the job will be aborted. If the IGNORE_DEADLINE
parameter is set in lsb.queues(5), this behavior is overridden and the
run limit is ignored.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-Zs
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Spools a job command file to the directory specified by the
JOB_SPOOL_DIR parameter in lsb.params, and uses the spooled file
as the command file for the job.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
By default, if JOB_SPOOL_DIR is not specified, the input file is spooled
to LSB_SHAREDIR/<I>cluster_name</I>/lsf_cmddir. If the lsf_cmddir
directory does not exist, openlava creates it before spooling the file. openlava
removes the spooled file when the job completes.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The <B>-Zs</B> option is not supported for embedded job commands because
openlava is unable to determine the first command to be spooled in an
embedded job command.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-h
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Prints command usage to stderr and exits.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B>-V
</TD><TD valign=bottom>
</B>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
Prints openlava release version to stderr and exits.
<P>
<P>
<!-- .TP  -->
</TD></TR>
<TR valign=top><TD colspan=2>
command [argument]
</TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job can be specified by a command line argument command, or
through the standard input if the command is not present on the
command line. The<I> command</I> can be anything that is provided to a
UNIX Bourne shell (see <B>sh</B>(1)). command is assumed to begin with the
first word that is not part of a <B>bsub</B> option. All arguments that follow
<I>command</I> are provided as the arguments to the <I>command</I>.
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
If the batch job is not given on the command line, <B>bsub</B> reads the job
commands from standard input. If the standard input is a controlling
terminal, the user is prompted with "bsub&gt;" for the commands of the
job. The input is terminated by entering CTRL-D on a new line. You
can submit multiple commands through standard input. The
commands are executed in the order in which they are given. <B>bsub</B>
options can also be specified in the standard input if the line begins
with #BSUB; e.g., "#BSUB -x". If an option is given on both the <B>bsub</B>
command line, and in the standard input, the command line option
overrides the option in the standard input. The user can specify the
shell to run the commands by specifying the shell path name in the first
line of the standard input, such as "#!/bin/csh". If the shell is not
given in the first line, the Bourne shell is used. The standard input
facility can be used to spool a user&#146;s job script; such as "bsub &lt;
script". See EXAMPLES below for examples of specifying commands
through standard input.
<P>
<P>
<!-- .SH OUTPUT -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>OUTPUT</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
If the job is successfully submitted, displays the job ID and the queue
to which the job has been submitted.
<!-- .SH EXAMPLES -->
</BLOCKQUOTE>
<A name=6>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
% <B>bsub sleep 2.0
</B>.IP
Submit the UNIX command sleep together with its argument 2.0
as a batch job.
<P>
<!-- .RE -->
</BLOCKQUOTE>
<!-- .PP -->
<P>
% <B>bsub -q short -o my_output_file "pwd; ls"
</B>.IP
Submit the LINUX command pwd and ls as a batch job to the queue
named short and store the job output in my_output file.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub -m "host1 host3 host8 host9" my_program
</B>.IP
Submit my_program to run on one of the candidate hosts: host1,
host3, host8 and host9.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub -q "queue1 queue2 queue3" -c 5 my_program
</B>.IP
Submit my_program to one of the candidate queues: queue1,
queue2, and queue3 which are selected according to the CPU time
limit specified by -c 5.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub -I ls
</B>.IP
Submit a batch interactive job which displays the output of ls at
the user&#146;s terminal.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub -Ip vi myfile
</B>.IP
Submit a batch interactive job to edit myfile.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub -Is csh
</B>.IP
Submit a batch interactive job that starts up csh as an interactive
shell.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub -b 20:00 -J my_job_name my_program
</B>.IP
Submit my_program to run after 8 p.m. and assign it the job name
my_job_name.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub my_script
</B>.IP
Submit my_script as a batch job. Since my_script is specified as a
command line argument, the my_script file is not spooled. Later
changes to the my_script file before the job completes may affect
this job.
<P>
<!-- .RE -->
<!-- .PP -->
<P>
% <B>bsub &lt; default_shell_script
</B>.IP
where default_shell_script contains:
<P>
<!-- .IP -->
<TABLE cellpadding=3>
<TR valign=top><TD width=6%>

</TD><TD>
sim1.exe
<!-- .br -->
<!-- Need break --><BR>
sim2.exe
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The file default_shell_script is spooled, and the commands
will be run under the Bourne shell since a shell specification is not
given in the first line of the script.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
% <B>bsub &lt; csh_script
</B>.IP
where csh_script contains:
<P>
<!-- .IP -->
<TABLE cellpadding=3>
<TR valign=top><TD width=6%>

</TD><TD>
#!/bin/csh
<!-- .br -->
<!-- Need break --><BR>
sim1.exe
<!-- .br -->
<!-- Need break --><BR>
sim2.exe
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
csh_script is spooled and the commands will be run under
/bin/csh.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
% <B>bsub -q night &lt; my_script
</B>.IP
where my_script contains:
<P>
<!-- .IP -->
<TABLE cellpadding=3>
<TR valign=top><TD width=6%>

</TD><TD>
#!/bin/sh
<!-- .br -->
<!-- Need break --><BR>
#BSUB -q test
<!-- .br -->
<!-- Need break --><BR>
#BSUB -o outfile -e errfile # my default stdout,
stderr files
<!-- .br -->
<!-- Need break --><BR>
#BSUB -m "host1 host2" # my default candidate hosts
<!-- .br -->
<!-- Need break --><BR>
#BSUB -f "input &gt; tmp" -f "output &lt;&lt; tmp"
<!-- .br -->
<!-- Need break --><BR>
#BSUB -D 200 -c 10/host1
<!-- .br -->
<!-- Need break --><BR>
#BSUB -t 13:00
<!-- .br -->
<!-- Need break --><BR>
#BSUB -k "dir 5"
<!-- .br -->
<!-- Need break --><BR>
sim1.exe
<!-- .br -->
<!-- Need break --><BR>
sim2.exe
<P>
<!-- .IP -->
</TD></TR>
<TR valign=top><TD width=6%>

</TD><TD>
The job is submitted to the night queue instead of test, because
the command line overrides the script.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
% <B>bsub -b 20:00 -J my_job_name
</B>.IP
bsub&gt; sleep 2.00
<!-- .br -->
<!-- Need break --><BR>
bsub&gt; my_program
<!-- .br -->
<!-- Need break --><BR>
bsub&gt; CTRL-D
<P>
<!-- .IP -->
<TABLE cellpadding=3>
<TR valign=top><TD width=6%>

</TD><TD>
The job commands are entered interactively.
<P>
<!-- .RE -->
</TD></TR>
<TR></TR></TABLE><!-- .SH LIMITATIONS -->
<A name=7>

     <H3>LIMITATIONS</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
When using account mapping the command bpeek(1) will not work.
File transfer via the -f option to bsub(1) requires rcp(1) to be
working between the submission and execution hosts. Use the -N
option to request mail, and/or the -o and -e options to specify an
output file and error file, respectively.
<!-- .SH SEE ALSO -->
</BLOCKQUOTE>
<A name=8>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<!-- .BR -->
 <!-- .PP -->
<P>
<!-- .PP -->
<P>
bjobs(1), bkill(1),bqueues(1), bhosts(1), bmgroup(1),
bmod(1), bchkpnt(1), brestart(1), sh(1), getrlimit(2),
sbrk(2), libckpt.a(3), lsb.users(5), lsb.queues(5),
lsb.params(5), lsb.hosts(5), mbatchd(8)
</BLOCKQUOTE>
<P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>bsub (1)</TD> <TD align=right width=33%><I>"openlava Version 2.0 - Jan 2012"</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.07</A> from bsub.1 using man macros.</FONT>
</BODY></HTML>
